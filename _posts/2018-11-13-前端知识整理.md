---
ilayout: post
title: "前端知识整理"
subtitle: "javascript HTML CSS  "
author: "Few"
header-img: "img/home-bg-art.jpg"
header-mask: 0.4
tags:
  - javascript
  - HTML 
typora-root-url: ../img
---



# 前端知识整理



# JavaScirpt

### 一  常用的内置对象及其方法

##### Math 对象

Math.abs( x ) : x 的绝对值

Math.ceil( x ) : x 向上取整后的值

Math.floor( x ) : x 向下取整后的值

Math.max( x, y, ... ) : 返回 0 到多个数值之中的最大值

Math.min( x, y , ...) : 返回 0 到多个数值之中的最小值

Math.random( ) : 返回 0 到 1 之间的随机数,包含 0 但不包含 1

Math.round( x ):  返回四舍五入后的整数



##### String 对象

String.length : 字符串的长度

String.concat("字符串1", "字符串2", ...) : 返回的是拼接后的字符串

String.indexOf("要找的字符串",从某个位置开始的索引) : 返回值是该字符串所在位置的索引,如果没有找到则返回 -1

String.replace("原来的字符串","新字符串") : 返回值是替换后的新的字符串

String.slice(开始的位置  [,  结束的位置]) : 返回值是从原字符串中提取出来的新的字符串

String.split("分隔符",切割后留下的字数) : 返回源字符串以分隔符出现位置分隔而成的一个 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array) 

String.substr(开始的位置 [,可选的字符数]) : 返回值是截取后的新的字符串

String.startsWith( ... ) : 是否以 ** 开头

String.ensWith( ... ) : 是否以**结尾

String.includes(...) ; 是否包含 ** 





##### Array 对象

Array.concat( 数组1 , 数组2 , ... ) : 合并两个或者多个数组,返回一个新的数组,并不会改变原有数组

**Array.filter( 处理函数 ) : 一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组**

**Array.forEach( function( elements [, index , array ]){  ... } ) : 遍历数组,数组中每一项执行定义的操作**

Array.push( 值 ) : 把值追加到数组的最后,**返回值是插入后的数组长度**

Array.pop(  ) : 删除数组最后的一个元素,返回值是删除的这个元素

Array.unshift( 值 ) : 在数组的开头插入一个元素,**返回值是插入后的数组长度**

Array\.shift(  ) : 删除数组开头的第一个元素,返回值是删除的这个元素

Array.indexOf( 值, 开始的索引 ) : 找出某个元素在数组中的索引,找不到就返回 -1 

Array.splice(开始的位置,要删除的个数,替换的元素的值) : 返回值是删除元素或者添加元素后的一个数组

Array.slice(开始的位置,结束的位置) : 一个含有提取元素的新数组

Array.reverse(  ) : 反转数组

Array.sort(  ) : 数组排序

Array.join( "字符串" ) : 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。

Array.map( function(   ){ ... } ) :`**map()**` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

Array.some( ... ) : 判断数组中至少有一个元素满足条件

Array.every( ... ) : 判断数组中的所有元素是否满足条件

Array.find( ... ) : 返回满足条件的第一个元素

Array.findIndex( ... ) : 返回满足条件的第一个元素的索引值





### 二 数据类型

简单数据类型 : number string boolean undefined null

复杂数据类型 : function 函数 object 对象

##### 注意:

简单数据类型传递的是值,复杂数据类型传递的是地址

**null : null 表示一个空的值,它和 0 和 "" 字符串不同, 0 是一个数值, "" 表示一个长度为 0 的字符串, 而 null 表示空 **                                                                                                                                                                    



**判断数据类型: **

**简单数据类型 : typeof       例 : typeof  变量 **

**复杂数据类型 : instanceof 例 : 对象 instanceof 构造函数**  



***相等转换原则(隐式转换) : 按照顺序依次转换***

***1 - NaN 与任何值不相等,包括它自身 NaN != NaN***

***2 - null 与任何值不相等,除了 null 和 undefined***

***3 - undefinef 与任何的值不相等,除了 null 和 undefined***

***4 - 如果操作数的两边有布尔类型或者数字,都转成数字进行比较***

***5 - 如果操作数两边都有字符串,都转成字符串进行比较***



### 三  DOM (Document Object Model) 文档对象模型  and BOM (Browser Object Model) 浏览器对象模型

	DOM 是一套可以操作页面的 API , DOM 可以把 HTML 看作是文档树, 通过 DOM 提供的Api可以对树立的节点进行操作



**API: Application Programming Interface 应用程序编程接口,目的是提供应用程序与开发人员基于某硬件或者软件得以访问一组例程的能力,而又无需访问源码,或者理解内部工作机制的细节**



##### DOM中常用的事件



![DOM 常用事件](../img/DOM 常用事件.png)

##### 事件对象: 在触发事件的时候,都会产生一个事件参数对象 Event ,这个对象中包含所有与事件相关的一些信息,包含出发时间的元素,事件类型与其他事件相关的信息



**事件对象的常用属性** : 

![事件对象常用属性](../img/事件对象常用属性.png)

clientX 和 clientY : 相对于浏览器左上角的距离

pageX 和 pageY : 相对于网页内容左上角

screenX 和 screenY : 相对于屏幕左上角的距离

#### offset系列

![offset系列](../img/offset系列.png)

offsetWidth , offsetHeight : 元素自身的真实宽高

offsetLeft: 元素自身左侧到 offsetParent 左侧的距离

offsetTop: 元素自身顶部到 offsetParent 顶部的距离



##### 事件流 : 从页面中接收事件的顺序

![事件流](../img/事件流.png)

事件流的三个阶段: 

事件捕获阶段: 事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标节点。(从上至下)

事件目标阶段:事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发

事件冒泡阶段: 事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点。(从下至上)



**如何阻止事件冒泡?**

**w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true;**

**取消默认事件**

**w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;**

**事件委托和事件绑定**

**事件绑定**: 将普通的事件 event 绑定在 DOM 节点上,当DOM节点被选中时，将事件与之绑定，方便用户提供相应的操作。

`$('.bn1').click(function(){...})`就是普通的事件绑定。

**事件委托:**是指在事件绑定的基础上补充与扩展事件绑定,具体就是指: 通过子节点元素绑定事件来传递 DOM 节点(祖先节点)来统一管理其全部后代子元素

```j&#39;s
$('.div').on('click','.bn2',function(){...})
```

**事件监听**: addEventListener(event, function, useCapture) 为一个元素注册多个互不相干的事件

### 四 逻辑中断

&&: 从左到右找假值,如果找到了,逻辑中断,返回假值(返回的是布尔类型为 false 的那个值的本身)

||: 从左到右找真值,如果找到了,逻辑中断,返回真值(返回的也是布尔类型为 true 的这个值的本身)

```js
var scrollTop = window.pageOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
```

### 五 面向过程和面向对象

面向过程: 执行者凡事都亲力亲为

面向对象: 指挥者对面向过程进行了封装

##### 面向对象三大特性

**封装**: 封装就是把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象进行操作,对不可信的进行信息隐藏.一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体.在一个对象内部,某些代码或者某些数据可以是私有的,不能被外界访问的,通过这种方式,对象对内部数据提供了不同级别的保护,以防止程序中无关的部分意外的改变或者错误的使用;了对象的私有部分

**继承**: 可以让某个类型的对象获得另一个类型对象的属性和方法

**多态**: JS 不支持多态,但是多态是指一个实例的相同方法在不同情形有不同饿表现形式



##### 面向对象的基本思路: 

1 在构造函数里写实例属性

2 在原型上写共享的数据

##### 当 new 一个新对象的时候,发生了下面几件事情

1 创建了一个新的对象

2 改变了this 的指向

3 给这个实例添加方法和属性

4 返回 this



### 六 原型相关

**原型的作用 : 数据共享,节省内存空间**

**原型的写法 : 构造函数. prototype. 属性 = 值**

		      构造函数.prototype.方法 = 函数

**简单原型的写法: var obj = { ... } 缺陷: 原型直接指向 Object, 没有构**

	任何函数都有 prototype 属性,函数的 ptototype 属性的值是一个对象,称之为原型对象,通过构造函数创建的实例对象可以直接访问这个构造函数的原型对象(prototype)上的任意成员

**(一般把实例对象需要共享的数据放在原型上,减少内存浪费的问题)**

	任何对象都有__ proto__ 属性,指向的是构造函数的 prototype (原型)
	
	**所以访问原型对象现在有两种途径,一是通过构造函数的 prototype 访问原型,二是通过实例对象的__ proto__ 访问原型**

#### 原型链

	任何对象都有__ proto__ 属性,指向了原型对象 prototype, 原型对象也是对象,原型也有__ proto__ 属性,指向了原型对象的原型属性,所以原型对象也有自己的原型对象,这样形成的一条链式结构就称之为原型链



![原型链](../img/原型链.png)任何对象的原型链上都有 Object.prototype 最终都指向 null

ren'he

##### 属性查找原则(属性搜索原则): 沿着原型链进行查找

(1) 对象查找属性,首先在当前对象自身上找,如果找到了该属性就直接返回

(2) 如果在对象自身上没有查找到,去对象的原型上进行查找,如果找到了直接返回

(3) 如果在对象的原型上没有找到,继续沿着对象的原型链向上查找,直到 Object.prototype, 如果找到了直接返回

(4) 如果都没有找到,就返回 undefined



#### Object.prototype 上的成员(属性)

	因为任何对象的原型链上都有 Object.prototype, 所以有必要熟悉 Object原型上的属性

##### (1) constructor: 构造器 

(指向它的构造函数 Object ,返回对创建此对象的数组函数的引用)

##### (2)hasOwnProperty( ... ) :是否有自己的属性

语法 : 对象. hasOwmProperty("属性") 

作用 : 判断该属性是否是对象自身的,如果是返回 true, 否则返回 false

##### In 和 hasOwnProperty 的区别

in 运算符: 判断属性能否被对象访问到,不管属性是对象自身的还是原型链上的,只要能够访问到到,就返回 true ,访问不到,就返回 false

语法 : "属性" in 对象

##### hasOwnProprety 的使用场景: 使用在 for ... in  的循环里,过滤出对象自身的属性, for ... in 在遍历对象的时候,会把对象自身和原型链上的属性都遍历到(可遍历的属性)

```js
for ( var key in object) {
    if (object.hasOwnProperty(key)){
        ...
    }
}
```



##### (3) propertyEnumerable( ... ) : 属性是否可以遍历

##### 语法: 对象. propertyEnumerable("属性") 

##### 作用:  判断属性是否可以遍历

	(1) 判断属性是否是对象自身的

(2) 判断属性是否可以遍历

	(2) 判断属性是否可以遍历

##### 只有满足了以上两个条件才返回 true

##### --	 Object.defineProperty( ... )  : 定义属性

语法 : Object.defineProperty( obj , prop , desc );

参数 1 : 给对象添加的属性指定是哪个对象

参数 2 : 给对象添加说明属性, 是个字符串

参数 3 : 属性描述,是个对象

```js
Object.defineProperty(obj , 'gender', Object.defineProperty(obj , 'gender,{
    value: female'',	// value 给这个对象的该属性设置默认值
    enumerable: true,	// enumerable 设置属性是否可以遍历 true/ 可遍历
    writable: false 	// writable 属性是否可以修改 true/ 可修改 
})
```

c

##### (4) isPrototyprOf ( ... ) : 是否是原型归属

语法 : 对象 A.isPrototypeOf(对象 B )

作用 : 判断 A 对象是否在 B 的原型链上

##### instanceof 和 isPrototypeOf 的区别

##### Instanceof:

##### 	语法: 对象 instanceof 构造函数

##### 	作用: 判断构造函数的 prototype 属性是否在对象的原型链上,如果在就返回 true

区别: 作用是一样的,区别在于写法

对象 A.isPrototyprOf(对象 B) // 判断 A 是否在对象 B 的原型链上

对象 B.instanceof A //判断 A 的 prototype 属性是否在 A 的原型链上( A 是构造函数 )



##### (5) valueOf(  ) , toString(  ) .toLocaleString(  )

valueOf( ... ) : 将对象转成原始值(简单数据类型) ,但是默认的(Object.prototype 上的 valueOf )只能返回对象自身

toString( ... ) : 将对象转换成字符串,每个内置对象上都提出来 toString() 方法

toLocaleString(...) : 和 toString 没有区别,在日期对象上的差异

对象在参与运算或者比较的时候, js 内部会帮我们自动调用 valueOf && toString 两个方法

##### 调用规则:

1 首先调用 valueOf 的方法,尝试将对象转换成简单数据类型,如果没有转成简单数据类型,就继续调用 toString 方法转成字符串

2 如果对象分别调用 valueOf 和 toString 两个方法,都没有转成简单数据类型,则报错



### 七 沙箱

	是一个独立和封装的环境,内部的代码是不会影响到外部的

	**自调用函数:创建了一个函数的同时调用了自己(一般一个 JS 文件只暴露一个核心变量(函数),减少全局污染——自调用函数也是沙箱模式)**



### 八 严格模式

	ES5提出来的一种代码运行模式

	开启严格模式——特殊的写法----" use strict" (这句话后面的所有的代码都遵循严格模式)

	严格模式下无法运行的代码:

	1 - 变量必须显示声明

	2 - 函数参数不能重名

	3 - 禁止使用八进制

	4 - 不能使用保留字作为变量名称

建议 : 不要在全局里面开启严格模式,一般严格模式配合沙箱去使用

注意点 : 一般开启严格模式" use strict" 必须写在当前作用域的最顶部

严格模式的好处 : 代码规范,执行效率高,为了以后的 JS 版本做铺垫



### 九 继承

混入式继承 : 拷贝一个对象的属性或者方法

原型链继承 : 通过构造函数创建的实例对象可以直接继承原型上的任意成员

混入式继承+原型链继承 : 

经典继承: Object.create( ... )

语法 : var newobj = Object.create(obj)

参数 obj : 是一个对象

作用 : 该方法创建的是一个空对象,返回的对象的原型是参数 obj



### 十 try...catch 尝试捕获

对于可能会报错的代码,使用 try...catch ,就会阻止报错

try : 尝试

catch : 捕获

```j&#39;s
try{
   try 中的代码是会被执行的,如果代码有错,会被 catch 捕获到进入 catch 语句,可以阻止报错,不会影响到后面代码的执行 
}catch{
    e : 是个错误对象
}

eval( ... ) 将字符串视为 JS 代码来执行和 new Function 的作用一样
```



### 十一  this 的指向问题

任何函数都有属于自己的 this

	**this 是动态性的,只有当函数调用的时候才能确定 this 的指向,也就是说,当函数写好了以后是不能确定 this 指向的, this 指向和函数在哪里被调用是没有关系的**



##### 分析 this 的思路(规律)

	this 是属于哪个函数的

	这个函数是如何被调用的

##### 函数的四种调用模式中的 this 的指向

	函数调用模式 :  this 指向 window

	对象(方法)调用模式 : this 的指向就是谁调用了这个方法, this 就指向谁

	构造函数模式 : this指向的是实例对象

	上下文模式(借用模式) : call apply bind (apply 内的第二个参数是数组或者伪数组)



### 十二 数组和伪数组

伪数组会经常借用数组的方法,伪数组是一个对象,有数字下标和 length 长度属性,能和数组一样遍历,但是不能使用数组的方法

特征:

	有数字下标

	有 length 属性

	不能使用数组的方法



### 十三 Function.prototype 成员

arguements : 是原型上的属性,函数的实参列表(已废弃)通过函数内部的 arguements 来获取

caller : 获取函数是在哪个函数里被调用的 (废弃)

constructor : 指向了构造函数 Function

length :函数形参的个数

name : 函数的名字

tostring : 转字符串



### 十四 预解析和作用域

预解析 : 预先解析

优先提升函数,然后是变量的提升,如果遇到重名的变量则忽略

作用域 : 变量声明后,能够在哪个范围内起作用

作用域链 : 函数能够形成作用域,如果函数被嵌套在另一个函数中,嵌套的函数也有自己的作用域,从这个作用域向外延伸形成的一条链称为作用域链 

**变量搜索规则,现在当前的作用域查找,找不到向上级查找,直到全局作用域,如果都没有就报错**



### 十五 递归

递归函数: 内部自己调用自己,注意的是一定要有结束的条件

递归的主要思想是将一个复杂问题转换为简单问题

**缓存 : 储存数据的容器 cache**

在 JS 里面,使用数组或者是对象用来做储存数据的容器,我们使用键储存,用键取值

使用缓存的思路 : 首先去容器里查看有没有对应的数据,如果有,直接取出来使用,如果没有,先去计算结果,把结果储存到缓存中,方便下次使用



### 十六 闭包

闭包是函数和声明该函数的司法环境的组合

函数 : 内部函数

声明该函数 :　外部函数

词法环境 :　作用域

组合 : 以上形成的综合体

形成的条件 : 有两个函数,是嵌套关系,内部函数访问了外部函数声明的变量

作用 : 私有化函数保护数据安全,持久化维持数据

问题 : 占有的内存是不会被释放的,造成内存泄露的问题

内存泄露 : 一块内存空间被占用了 ,一直得不到回收,别的对象就使用不了这块空间



# AJAX(Asynchoronous Javascript And XML)

AJAX 不是一门新的语言,而是对现有持术的综合利用

**本质 : 是在 HTTP 协议的基础上通过 js 的 XMLHttpRequest 对象与服务器进行通信**

**作用 : 可以在页面不刷新的情况下,请求服务器,局部更新页面数据**



#### XMLHttpRequest

浏览器内建对象,用于后台与服务器通信(交互数据),由此我们便可以实现对网页的部分更新,而不是刷新整个页面

##### HTTP 协议



##### 发送 get 请求

XMLHttpRequest 以异步的方式发送 HTTP 请求,因此在发送请求时候,一样要遵循 HTTP 协议

```js
// 1 创建一个 XMLHttpRequest 对象
const xhr = new XMLHttpRequest();
// 2 设置请求行
xhr.open('get',请求地址);
// 3 设置请求头 get 请求无须设置
xhr.setRequestHeader('content-type','text/html');
// 4 设置请求体 get 请求的请求体为空,因为参数拼接到 url 后面了
xhr.send(null);

注意点: 
get 请求设置请求行时,需要把参数拼接到 url 后面
get 请求不用设置请求头
get 请求的请求体为 null
```



发送 post 请求







发送 post 请求



##### 发送 post 请求

```js
// 创建一个 XMLHttprequest 对象
const xhr = new XMLHttpRequest();
// 设置请求行
xhr.open('post',请求地址);
// 设置请求头 post 请求必须设置 content-type 属性
xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
// 设置请求主题
xhr.send('name=sss&age=18');
```



##### 响应 (HTTP 响应分为3个部分,响应行,响应头,响应体)

```js
// 给 xhr 注册一个 onreadystatechange 事件,当 xhr 状态发生状态改变的时候,就会触发这个事件
xhr.onreadystatechange = function(){
    if(xhr.readyState ===4 && xhr.status===200){
        // 响应体
        let text = xhr.responseText
    }
}

readyState : 记录了 XMLHttpRequest 对象的当前状态
0: 请求未初始化(还没有调用 open )
1: 请求已经建立,但是还没有发送(还有没调用 send())
2: 请求已发送,正在处理中
3: 请求正在处理中;通常响应中已经有部分数据可以用来,但是服务器还没有响应的生成
4: 响应已经完成,可以获取并使用服务器的响应了
```



##### XML 和  JSON

##### XML:

XML 是指可扩展标记语言

XML 的设计宗旨是传输数据而非显示数据

XML 的标签没有被预定义,需要自行定义标签

**语法规范**

- 第一行必须是版本信息
- 必须有一个根元素（有且仅有一个）
- 标签不可有空格、不可以数字或.开头、大小写敏感
- 不可交叉嵌套，都是双标签，如果是单标签，必须闭合
- 属性双引号（浏览器自动修正成双引号了）
- 特殊符号要使用实体 
- 注释和HTML一样

##### JSON

JSON(JavaScirpt Object Notation)是一种轻量级的数据交换格式,用来储存和表示数据



##### 模板引擎

### artTemplate入门

**1.引入模板引擎的js文件** 

```javascript
<script src="template-web.js"></script>
```

**2.准备模板** 

```html
<!--
  指定了type为text/template后，这一段script标签并不会解析，也不会显示。
-->
<script type="text/template" id="tmp">
  <p>姓名：{{ username }}</p>  
  <p>年龄：{{ age }}</p>
  <p>技能：{{ skill }}</p>
  <p>描述：{{desc }}</p>
</script>
```

**3.准备数据**

```javascript
//3. 准备数据,数据是后台获取的，可以随时变化
var json = {
  userName:"隔壁老王",
  age:18,
  skill:"查水表",
  desc:"年轻气壮"
}
```

**4.将模板与数据进行绑定**

```javascript
//第一个参数：模板的id
//第二个参数：数据
//返回值：根据模板生成的字符串。
var html = template("myTmp", json);
console.log(html);
```

**5.将数据显示到页面**

```javascript
var div = document.querySelector("div");
div.innerHTML = html;
```

**注意：传递给模板引擎的数据必须是对象**

### artTemplate语法

**if语法**

```html
{{if gender='男'}}
  <div class="man">
{{else}}
  <div class="woman">
{{/if}}
```

**each语法**

```html
<!--
  1. {{each data}}  可以通过$value 和 $index获取值和下标
  2. {{each data v i}}  自己指定值为v，下标为i
-->
{{each data v i}}
<li>
  <a href="{{v.url}}">
    <img src="{{v.src}}" alt="">
    <p>{{v.content}}</p>
   </a>
 </li>
{{/each}}
```

```javascript
//如果返回的数据是个数组，必须使用对象进行包裹，因为在{{}}中只写书写对象的属性。
var html = template("navTmp", {data:info});
```

##### 同源和跨域

同源

同源策略 : 协议相同,域名相同,端口相同   不同源则跨域

同源策略的目的 : 是为了保护用户信息的安全,防止恶意网站窃取数据

跨域







# node.js

##### global 全局

在浏览器中的全局变量是 window, 在 node 中也有一个全局变量 global 

全局变量在任何地方都可以直接使用

global 提供的相关方法和属性 : 

console.log( ) : 打印信息

setInterval( ... ) : 定时器

setTimeout( ... ) : 延时器

clearInterval( ... ) : 清除定时器

clearsetTimeout( ... ) : 清除延时器

__dirname 获取当前文件的绝对路径

__filename 获取当前文件的全名

##### fs 模块

文件读取

```js
// 导入 fs 模块
const fs = require('fs');

// 文件读取
fs.readFile(文件路径,[文件编码], function(err, data ){ ... } )  
参数1: 文件路径
参数2: 读取文件完成的回调函数
	err : 错误信息
	data : 读取文件的数据
	data 中的数据默认是二进制的,是一个 buffer对象,可以读取任何文件,可以通过 buffer.toString()将二进制的数据转换成字符串
```

文件写入

```js
// 导入 fs 模块
const fs = require('fs');
// 文件写入
fs.writeFile(文件路径,数据,[编码],(err)=>{ ... });
参数1: 文件路径
参数2: 数据
参数3: 文件编码[可选]
参数4: 错误的回调函数
```

追加内容

```js
// 导入 fs 模块
const fs = require('fs');
// 追加内容
fs.appendFile(文件路径,数据,[编码],(err)=>{ ... })
参数1: 文件路径
参数2: 数据
参数3: 文件编码[可选]
参数4: 错误的回调函数

```

删除文件

```js
// 导入 js 模块
const fs = require('fs');
// 删除内容
fs.unlink(文件路径,(err)=>{ ... });
```

重命名模块

```js
// 导入 fs 模块
const fs = require('fs');
// 重命名
fs.rename(文件路径,新文件名,(err)=>{ ... })
```



##### 注意: 

	**在操作文件时,在代码写相对路径,并不是相对与文件所在的位置,而是相对于 node 命令执行的位置,所以操作文件建议使用绝对路径**

```js
__dirname + 文件路径
```

##### path 模块

path.join : 使用 path.join 来拼接路径,可以解决不同操作系统之间的路径兼容问题  

```js
// 引入 path 模块
const path = require('path');

// path.join
path.join('aa','bb','cc','dd.txt');
```

path.basename() :  返回文件的最后一个部分

path.dirname() : 返回路径的目录名

Path.extname() : 返回路径的扩展名

**path 模块优化文件路径**

```js
 path.join(__dirname,'data','news.txt');
```



##### http 模块

```js
// 引入 http 模块
const http = require('http');
// 创建一个服务器
const sever = http.createSever();
// 监听请求,处理请求
// 通过 req 获取请求报文的数据
// 通过 res 设置响应报文的数据
sever.on('request',function(req,res){
    //设置响应主体
    res.write('hh');
    res.end();
});

// 设置端口 打开服务器
sever.listen(9999,function(){
    console.log('服务器已经启动');
})
```

```js
// req 请求报文对象  用于获取请求报文数据
// res 响应报文对象  设置响应报文数据 

// 请求报文req的属性
// req.url  请求地址
// req.method 请求方式 
// req.headers 请求头
//通过res 设置 响应报文 
// 状态码 状态文本 
res.statusCode = 200;
// res.statusMessage = 'aaa';
// 状态文本不能使用中文， 状态文本一般不需要设置， 会根据状态码 自动设置；
res.statusMessage = '未找到页面';
// 响应头 
//header()
res.setHeader('content-type', 'text/html;charset=utf-8');
// 响应主体 
// echo '嘿嘿嘿';
// 响应主体
res.write('嘿嘿嘿');

res.end('ok'); //告诉浏览器响应结束的 
```







### 面试方面

##### 1 让不定宽高的 DIV, 垂直水平居中

```css
方法一:
父盒子: display:table-cell; text-align:center;vertical-align:center
子盒子: display:inline-block; vertical-align:middle

方法二:
父盒子: position:relative;
子盒子: position:absolute; left:50%;top:50%;transform:translate(-50%,-50%);

方法三:
父盒子: display:flex;justify-content:center;align-item:center
```

##### 2 px em rem

px 像素是绝对单位,是相对于显示器屏幕分辨率而言的

em 是相对单位,相对于当前文本内的字体尺寸

rem 是相对单位,相对于 HTML 根元素的字体大小



##### 3 什么是BFC

	BFC(Block formatting context)直译为块级格式化上下文,是一个独立渲染的区域,只有块级水平盒子参与,规定了盒子内的布局不与外部相干



##### 4 渐进增强和优雅降级

渐进增强 : 针对低版本浏览器进页面重构,保证最基本的功能,然后针对高版本的浏览器追加功能达到更好的用户体验

优雅降级 : 一开始就构建完整的功能,再针对低版本浏览器进行兼容

##### 5 CSS hack

 针对不同浏览器写不同的 css 代码被称为 css hack

##### 6 display: inline-block 什么时候会显示间隙

真正意义上的 inline-block 水平呈现的元素间,换行显示或者空格分隔的情况下会有间距

##### 7 css 初始化样式的目的

浏览器兼容 : 不同浏览器的标签的默认样式是不同的,不进行初始化会有浏览器之间页面差异

##### 8 盒子布局的好处 div + css

表现和内容相分离

提高搜索引擎对网页的索引效率

提高页面的浏览速速

易于维护和改版

##### 9 网页的重绘重排以及重构

重绘: 元素外观改变触发的流浪器行为,并不一定的伴随重排

重排:结构发生改变,更新渲染树

重构: 页面重构,网站重构

 



































