---
ilayout: post
title: "前端知识整理"
subtitle: "javascript HTML CSS  "
author: "Few"
header-img: "img/home-bg-art.jpg"
header-mask: 0.4
tags:
  - javascript
  - HTML 
---



# 前端知识整理



## JavaScirpt

### 一  常用的内置对象及其方法

##### Math 对象

Math.abs( x ) : x 的绝对值

Math.ceil( x ) : x 向上取整后的值

Math.floor( x ) : x 向下取整后的值

Math.max( x, y, ... ) : 返回 0 到多个数值之中的最大值

Math.min( x, y , ...) : 返回 0 到多个数值之中的最小值

Math.random( ) : 返回 0 到 1 之间的随机数,包含 0 但不包含 1

Math.round( x ):  返回四舍五入后的整数



##### String 对象

String.length : 字符串的长度

String.concat("字符串1", "字符串2", ...) : 返回的是拼接后的字符串

String.indexOf("要找的字符串",从某个位置开始的索引) : 返回值是该字符串所在位置的索引,如果没有找到则返回 -1

String.replace("原来的字符串","新字符串") : 返回值是替换后的新的字符串

String.slice(开始的位置  [,  结束的位置]) : 返回值是从原字符串中提取出来的新的字符串

String.split("分隔符",切割后留下的字数) : 返回源字符串以分隔符出现位置分隔而成的一个 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array) 

String.substr(开始的位置 [,可选的字符数]) : 返回值是截取后的新的字符串



##### Array 对象

Array.concat( 数组1 , 数组2 , ... ) : 合并两个或者多个数组,返回一个新的数组,并不会改变原有数组

Array.filter( 处理函数 ) : 一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组

Array.forEach( function( elements [, index , array ]){  ... } ) : 遍历数组,数组中每一项执行定义的操作

Array.push( 值 ) : 把值追加到数组的最后,**返回值是插入后的数组长度**

Array.pop(  ) : 删除数组最后的一个元素,返回值是删除的这个元素

Array.unshift( 值 ) : 在数组的开头插入一个元素,**返回值是插入后的数组长度**

Array\.shift(  ) : 删除数组开头的第一个元素,返回值是删除的这个元素

Array.indexOf( 值, 开始的索引 ) : 找出某个元素在数组中的索引,找不到就返回 -1 

Array.splice(开始的位置,要删除的个数,替换的元素的值) : 返回值是删除元素或者添加元素后的一个数组

Array.slice(开始的位置,结束的位置) : 一个含有提取元素的新数组

Array.reverse(  ) : 反转数组

Array.sort(  ) : 数组排序

Array.join( "字符串" ) : 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。

Array.map( function(   ){ ... } ) :`**map()**` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。



### 二 数据类型

简单数据类型 : number string boolean undefined null

复杂数据类型 : function 函数 object 对象

##### 注意:

简单数据类型传递的是值,复杂数据类型传递的是地址

**null : null 表示一个空的值,它和 0 和 "" 字符串不同, 0 是一个数值, "" 表示一个长度为 0 的字符串, 而 null 表示空 **                                                                                                                                                                    



**判断数据类型: **

**简单数据类型 : typeof       例 : typeof  变量 **

**复杂数据类型 : instanceof 例 : 对象 instanceof 构造函数**  



***相等转换原则(隐式转换) : 按照顺序依次转换***

***1 - NaN 与任何值不相等,包括它自身 NaN != NaN***

***2 - null 与任何值不相等,除了 null 和 undefined***

***3 - undefinef 与任何的值不相等,除了 null 和 undefined***

***4 - 如果操作数的两边有布尔类型或者数字,都转成数字进行比较***

***5 - 如果操作数两边都有字符串,都转成字符串进行比较***



### 三  DOM (Document Object Model) 文档对象模型  and BOM (Browser Object Model) 浏览器对象模型

	DOM 是一套可以操作页面的 API , DOM 可以把 HTML 看作是文档树, 通过 DOM 提供的Api可以对树立的节点进行操作



**API: Application Programming Interface 应用程序编程接口,目的是提供应用程序与开发人员基于某硬件或者软件得以访问一组例程的能力,而又无需访问源码,或者理解内部工作机制的细节**



##### DOM中常用的事件



![DOM 常用事件](/Users/xxx/Desktop/Few.github.io/img/DOM 常用事件.png)

##### 事件对象: 在触发事件的时候,都会产生一个事件参数对象 Event ,这个对象中包含所有与事件相关的一些信息,包含出发时间的元素,事件类型与其他事件相关的信息



**事件对象的常用属性** : 

![事件对象常用属性](/Users/xxx/Desktop/Few.github.io/img/事件对象常用属性.png)

clientX 和 clientY : 相对于浏览器左上角的距离

pageX 和 pageY : 相对于网页内容左上角

screenX 和 screenY : 相对于屏幕左上角的距离

#### offset系列

![offset系列](/Users/xxx/Desktop/Few.github.io/img/offset系列.png)

offsetWidth , offsetHeight : 元素自身的真实宽高

offsetLeft: 元素自身左侧到 offsetParent 左侧的距离

offsetTop: 元素自身顶部到 offsetParent 顶部的距离



##### 事件流 : 从页面中接收事件的顺序

![事件流](/Users/xxx/Desktop/Few.github.io/img/事件流.png)

事件流的三个阶段: 

事件捕获阶段: 事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标节点。(从上至下)

事件目标阶段:事件到达目标节点时，就到了目标阶段，事件在目标节点上被触发

事件冒泡阶段: 事件在目标节点上触发后，不会终止，一层层向上冒，回溯到根节点。(从下至上)



**如何阻止事件冒泡?**

**w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true;**

**取消默认事件**

**w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;**

**事件委托和事件绑定**

**事件绑定**: 将普通的事件 event 绑定在 DOM 节点上,当DOM节点被选中时，将事件与之绑定，方便用户提供相应的操作。

`$('.bn1').click(function(){...})`就是普通的事件绑定。

**事件委托:**是指在事件绑定的基础上补充与扩展事件绑定,具体就是指: 通过子节点元素绑定事件来传递 DOM 节点(祖先节点)来统一管理其全部后代子元素

```j&#39;s
$('.div').on('click','.bn2',function(){...})
```

**事件监听**: addEventListener(event, function, useCapture) 为一个元素注册多个互不相干的事件

### 四 逻辑中断

&&: 从左到右找假值,如果找到了,逻辑中断,返回假值(返回的是布尔类型为 false 的那个值的本身)

||: 从左到右找真值,如果找到了,逻辑中断,返回真值(返回的也是布尔类型为 true 的这个值的本身)

```js
var scrollTop = window.pageOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
```

### 五 面向过程和面向对象

面向过程: 执行者凡事都亲力亲为

面向对象: 指挥者对面向过程进行了封装

##### 面向对象三大特性

**封装**: 封装就是把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象进行操作,对不可信的进行信息隐藏.一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体.在一个对象内部,某些代码或者某些数据可以是私有的,不能被外界访问的,通过这种方式,对象对内部数据提供了不同级别的保护,以防止程序中无关的部分意外的改变或者错误的使用;了对象的私有部分

**继承**: 可以让某个类型的对象获得另一个类型对象的属性和方法

**多态**: JS 不支持多态,但是多态是指一个实例的相同方法在不同情形有不同饿表现形式



##### 面向对象的基本思路: 

1 在构造函数里写实例属性

2 在原型上写共享的数据

##### 当 new 一个新对象的时候,发生了下面几件事情

1 创建了一个新的对象

2 改变了this 的指向

3 给这个实例添加方法和属性

4 返回 this



### 六 原型相关

**原型的作用 : 数据共享,节省内存空间**

**原型的写法 : 构造函数. prototype. 属性 = 值**

		      构造函数.prototype.方法 = 函数

**简单原型的写法: var obj = { ... } 缺陷: 原型直接指向 Object, 没有构**

	任何函数都有 prototype 属性,函数的 ptototype 属性的值是一个对象,称之为原型对象,通过构造函数创建的实例对象可以直接访问这个构造函数的原型对象(prototype)上的任意成员

**(一般把实例对象需要共享的数据放在原型上,减少内存浪费的问题)**

	任何对象都有__ proto__ 属性,指向的是构造函数的 prototype (原型)

	**所以访问原型对象现在有两种途径,一是通过构造函数的 prototype 访问原型,二是通过实例对象的__ proto__ 访问原型**

#### 原型链

	任何对象都有__ proto__ 属性,指向了原型对象 prototype, 原型对象也是对象,原型也有__ proto__ 属性,指向了原型对象的原型属性,所以原型对象也有自己的原型对象,这样形成的一条链式结构就称之为原型链



![原型链](/Users/xxx/Desktop/Few.github.io/img/原型链.png)任何对象的原型链上都有 Object.prototype 最终都指向 null

ren'he

##### 属性查找原则(属性搜索原则): 沿着原型链进行查找

(1) 对象查找属性,首先在当前对象自身上找,如果找到了该属性就直接返回

(2) 如果在对象自身上没有查找到,去对象的原型上进行查找,如果找到了直接返回

(3) 如果在对象的原型上没有找到,继续沿着对象的原型链向上查找,直到 Object.prototype, 如果找到了直接返回

(4) 如果都没有找到,就返回 undefined



#### Object.prototype 上的成员(属性)

	因为任何对象的原型链上都有 Object.prototype, 所以有必要熟悉 Object原型上的属性

##### (1) constructor: 构造器 

(指向它的构造函数 Object ,返回对创建此对象的数组函数的引用)

##### (2)hasOwnProperty( ... ) :是否有自己的属性

语法 : 对象. hasOwmProperty("属性") 

作用 : 判断该属性是否是对象自身的,如果是返回 true, 否则返回 false

##### In 和 hasOwnProperty 的区别

in 运算符: 判断属性能否被对象访问到,不管属性是对象自身的还是原型链上的,只要能够访问到到,就返回 true ,访问不到,就返回 false

语法 : "属性" in 对象

##### hasOwnProprety 的使用场景: 使用在 for ... in  的循环里,过滤出对象自身的属性, for ... in 在遍历对象的时候,会把对象自身和原型链上的属性都遍历到(可遍历的属性)

```js
for ( var key in object) {
    if (object.hasOwnProperty(key)){
        ...
    }
}
```



##### (3) propertyEnumerable( ... ) : 属性是否可以遍历

##### 语法: 对象. propertyEnumerable("属性") 

##### 作用:  判断属性是否可以遍历

	(1) 判断属性是否是对象自身的

(2) 判断属性是否可以遍历

	(2) 判断属性是否可以遍历

##### 只有满足了以上两个条件才返回 true

##### --	 Object.defineProperty( ... )  : 定义属性

语法 : Object.defineProperty( obj , prop , desc );

参数 1 : 给对象添加的属性指定是哪个对象

参数 2 : 给对象添加说明属性, 是个字符串

参数 3 : 属性描述,是个对象

```js
Object.defineProperty(obj , 'gender', Object.defineProperty(obj , 'gender,{
    value: female'',	// value 给这个对象的该属性设置默认值
    enumerable: true,	// enumerable 设置属性是否可以遍历 true/ 可遍历
    writable: false 	// writable 属性是否可以修改 true/ 可修改 
})
```

c

##### (4) isPrototyprOf ( ... ) : 是否是原型归属

语法 : 对象 A.isPrototypeOf(对象 B )

作用 : 判断 A 对象是否在 B 的原型链上

##### instanceof 和 isPrototypeOf 的区别

#####  



# 面试题汇总

### HTML 和  CSS



### JavaScript



### jQuery



### AJAX



### PHP 和 MySQL



### Bootstrap



### SASS / LESS 

